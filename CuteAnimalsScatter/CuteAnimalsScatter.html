<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Разброс зверят — тренажёр подсчёта</title>
  <link rel="icon" href="favicon.ico">
  <meta name="color-scheme" content="light dark">
  <style>
    html, body { margin:0; height:100%; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; color:#182230; }
    .topbar { position:fixed; top:0; left:0; right:0; height:54px; display:flex; align-items:center; justify-content:space-between; padding:0 16px; background:#ffffffcc; backdrop-filter: blur(6px); border-bottom:1px solid #d8dde7; z-index:10; }
    .title { font-weight:700; }
    .btn { background:#2b68e5; color:#fff; border:0; padding:8px 14px; border-radius:10px; cursor:pointer; font-weight:600; }
    .btn:hover { opacity:.9; }

    .canvas-wrap { position:absolute; top:54px; left:0; right:0; bottom:140px; display:flex; align-items:center; justify-content:center; padding:12px; box-sizing:border-box; }
    .counting-panel {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      height: 120px;
      background: rgba(255,255,255,0.95);
      border-top: 1px solid #d8dde7;
      padding: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 20px;
      overflow-x: auto;
      overflow-y: hidden;
    }
    .count-fields-container {
      display: flex;
      gap: 16px;
      align-items: center;
      flex-shrink: 0;
    }
    .count-field {
      display: flex;
      align-items: center;
      gap: 8px;
      background: #f6f8fe;
      border: 1px solid #dbe3f7;
      border-radius: 8px;
      padding: 8px 12px;
      min-width: 140px;
      flex-shrink: 0;
    }
    .count-field.correct { border-color: #4ade80; background: #dcfce7; }
    .count-field.incorrect { border-color: #f87171; background: #fef2f2; }
    .count-field input {
      width: 60px;
      background: transparent;
      border: none;
      color: #182230;
      font-size: 16px;
      text-align: center;
      outline: none;
    }
    .count-field input:focus { background: rgba(0,0,0,0.05); border-radius: 4px; }
    .animal-icon {
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .check-btn {
      background: #2b68e5;
      color: #fff;
      border: 0;
      padding: 12px 20px;
      border-radius: 10px;
      cursor: pointer;
      font-weight: 600;
      font-size: 16px;
    }
    .check-btn:hover { opacity: 0.9; }
    .total-field {
      background: #f6f8fe;
      border: 1px solid #dbe3f7;
      border-radius: 8px;
      padding: 8px 12px;
      min-width: 120px;
      text-align: center;
      font-weight: 600;
    }
    .total-field.correct { border-color: #4ade80; background: #dcfce7; }
    .total-field.incorrect { border-color: #f87171; background: #fef2f2; }
    .stage { position:relative; background:#f7f7fa; border:1px solid #cfd6e6; border-radius:12px; box-shadow:0 10px 30px rgba(0,0,0,0.12); overflow:hidden; background-image:url('фон 1.jpg'); background-size:cover; background-position:center; }
    canvas { width:100%; height:100%; display:block; }

    .overlay { position:fixed; inset:0; display:none; align-items:center; justify-content:center; z-index:20; background:rgba(0,0,0,0.35); padding:16px; }
    .panel { width:min(900px,96vw); max-height:92vh; overflow:auto; background:#ffffff; color:#182230; border:1px solid #d8dde7; border-radius:14px; padding:16px; box-shadow:0 12px 40px rgba(0,0,0,0.25); }
    .grid { display:grid; grid-template-columns: repeat(2, minmax(0,1fr)); gap:12px; }
    .field { display:grid; grid-template-columns:1fr auto; gap:8px; align-items:center; background:#f6f8fe; border:1px solid #dbe3f7; border-radius:10px; padding:10px; }
    .num { width:84px; padding:8px 10px; border-radius:8px; border:1px solid #c0c9e2; }
    .muted { opacity:.8; font-size:12px; }
    .panel-actions { display:flex; gap:10px; justify-content:flex-end; margin-top:12px; }
    .animals { display:grid; grid-template-columns: repeat(4, minmax(0,1fr)); gap:8px; }
    .animal-tile { background:#f6f8fe; border:1px solid #dbe3f7; border-radius:12px; padding:8px; display:grid; grid-template-rows: auto auto auto; gap:6px; user-select:none; cursor:pointer; }
    .animal-tile.active { outline:2px solid #2b68e5; }
    .animal-name { font-size:13px; font-weight:600; text-align:center; }
    .mini-nums { display:grid; grid-template-columns: 1fr 1fr; gap:6px; }
    .mini-nums .num { width:100%; box-sizing:border-box; }
  </style>
</head>
<body>
  <div class="topbar">
    <div class="title">Считалка: котики, осьминоги и божьи коровки</div>
    <div style="display:flex; gap:8px; align-items:center;">
      <button id="btn-new" class="btn">Новая игра</button>
      <button id="btn-settings" class="btn" style="background:#50658f;">Настройки</button>
    </div>
  </div>

  <div class="canvas-wrap">
    <div id="stage" class="stage">
      <canvas id="view"></canvas>
    </div>
  </div>

  <div class="counting-panel">
    <div class="count-fields-container" id="countFields"></div>
    <div class="total-field" id="totalField">
      <div>Всего ног у всех</div>
      <input id="totalInput" type="number" min="0" max="999" placeholder="?" style="width:60px; background:transparent; border:none; color:#182230; font-size:16px; text-align:center; outline:none; margin-top:4px;">
    </div>
    <button id="checkBtn" class="check-btn">Проверить</button>
  </div>

  <div id="overlay" class="overlay">
    <div class="panel">
      <h3 style="margin:0 0 10px 0;">Настройки</h3>
      <div class="grid">
        <div class="field">
          <label>Сколько типов участвует</label>
          <input id="participatingCount" class="num" type="number" min="1" max="8" value="3">
        </div>
        <div class="field">
          <label>Радиус элемента (px)</label>
          <input id="itemRadius" class="num" type="number" min="10" max="40" value="22">
        </div>
        <div class="field">
          <label>Масштаб (%)</label>
          <input id="scalePercent" class="num" type="number" min="50" max="300" value="100">
        </div>
        <div class="field">
          <label>Доп. зазор (px)</label>
          <input id="extraGap" class="num" type="number" min="0" max="40" value="4">
        </div>
      </div>
      <h4 style="margin:14px 0 8px 0;">Выберите кто участвует и задайте мин/макс для каждого:</h4>
      <div id="animalGrid" class="animals"></div>
      <div class="muted" style="margin-top:6px;">Если выбрано больше, чем указано в "сколько участвует" — будут случайные без повторов. Если выбрано меньше — используем всех выбранных.</div>
      <div class="panel-actions">
        <button id="btn-randomize" class="btn" style="background:#7a91bd;">Случайные настройки</button>
        <div style="flex:1"></div>
        <button id="btn-cancel" class="btn" style="background:#8e98ad;">Отмена</button>
        <button id="btn-apply" class="btn">Применить</button>
      </div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('view');
    const ctx = canvas.getContext('2d');
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const stage = document.getElementById('stage');
    const wrap = document.querySelector('.canvas-wrap');

    const overlay = document.getElementById('overlay');
    const animalGrid = document.getElementById('animalGrid');
    const ui = {
      participatingCount: document.getElementById('participatingCount'),
      itemRadius: document.getElementById('itemRadius'),
      scalePercent: document.getElementById('scalePercent'),
      extraGap: document.getElementById('extraGap'),
    };
    const btnNew = document.getElementById('btn-new');
    const btnSettings = document.getElementById('btn-settings');
    const btnApply = document.getElementById('btn-apply');
    const btnCancel = document.getElementById('btn-cancel');
    const btnRandomize = document.getElementById('btn-randomize');
    const countFields = document.getElementById('countFields');
    const totalField = document.getElementById('totalField');
    const totalInput = document.getElementById('totalInput');
    const checkBtn = document.getElementById('checkBtn');

    function resizeCanvas(){
      const cont = wrap.getBoundingClientRect();
      const maxW = Math.max(200, cont.width - 24);
      const maxH = Math.max(200, cont.height - 24);
      const ratio = 16/9; let w = maxW; let h = w/ratio; if (h>maxH){ h=maxH; w=h*ratio; }
      stage.style.width = Math.floor(w) + 'px'; stage.style.height = Math.floor(h) + 'px';
      const rect = stage.getBoundingClientRect();
      canvas.width = Math.floor(rect.width * dpr); canvas.height = Math.floor(rect.height * dpr);
      canvas.style.width = rect.width + 'px'; canvas.style.height = rect.height + 'px';
      ctx.setTransform(dpr,0,0,dpr,0,0);
      drawScene(lastState);
    }
    window.addEventListener('resize', resizeCanvas);

    // Группы зверят по количеству ног (в настройках показываем только первый вариант)
    const ANIMAL_GROUPS = [
      { groupId: 'g2',  legs: 2, name: 'Двуногий',    variants: [
        { id: 'twoleg',  src: 'двуногий.png' },
        { id: 'twoleg2', src: 'двуногий2.png' },
      ]},
      { groupId: 'g3',  legs: 3, name: 'Трехногий',   variants: [
        { id: 'threeleg',  src: 'трехногий.png' },
        { id: 'threeleg2', src: 'трехногий2.png' },
      ]},
      { groupId: 'g4',  legs: 4, name: 'Котик',       variants: [
        { id: 'cat', src: 'котик.png' },
      ]},
      { groupId: 'g5',  legs: 5, name: 'Пятиногий',   variants: [
        { id: 'fiveleg',  src: 'пятиногий.png' },
        { id: 'fiveleg2', src: 'пятиногий2.png' },
      ]},
      { groupId: 'g6',  legs: 6, name: 'Шестиногий',  variants: [
        { id: 'sixleg',   src: 'шестиногий.png' },
        { id: 'ladybug',  src: 'божья коровка.png' }, // шестиногий (вариант 2)
      ]},
      { groupId: 'g7',  legs: 7, name: 'Семиногий',   variants: [
        { id: 'sevenleg', src: 'семиногий.png' },
      ]},
      { groupId: 'g8',  legs: 8, name: 'Осьминог',    variants: [
        { id: 'octopus',  src: 'осьминог.png' },
      ]},
      { groupId: 'g9',  legs: 9, name: 'Девятиногий', variants: [
        { id: 'nineleg',  src: 'девятиногий.png' },
      ]},
    ].sort((a,b) => a.legs - b.legs);

    // Плоский список всех вариантов для предзагрузки
    const ALL_VARIANTS = ANIMAL_GROUPS.flatMap(g => g.variants.map(v => ({...v})));
    const GROUP_BY_ID = Object.fromEntries(ANIMAL_GROUPS.map(g => [g.groupId, g]));
    const IMAGES = new Map();
    function preloadImages(list){
      return Promise.all(list.map(item => new Promise((resolve) => {
        const img = new Image();
        img.onload = () => { IMAGES.set(item.id, img); resolve(); };
        img.onerror = () => { resolve(); };
        img.src = item.src;
      })));
    }

    function randInt(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }
    function distance(ax,ay,bx,by){ return Math.hypot(ax-bx, ay-by); }
    function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
    function shuffle(arr){ for(let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]]; } return arr; }
    function pickActiveTypes(selectedSet, participatingCount){
      const ids = Array.from(selectedSet);
      if (ids.length === 0) return [];
      const k = Math.min(ids.length, Math.max(1, participatingCount|0));
      return shuffle(ids.slice()).slice(0, k);
    }

    // Выбор и мин/макс — по группе (а не по варианту)
    const selectedGroupIds = new Set(ANIMAL_GROUPS.map(g => g.groupId));
    const perGroup = new Map(); // groupId -> {min,max}
    ANIMAL_GROUPS.forEach(g => perGroup.set(g.groupId, { min: 3, max: 6 }));

    function renderAnimalGrid(){
      animalGrid.innerHTML = '';
      ANIMAL_GROUPS.forEach(g => {
        const tile = document.createElement('div');
        tile.className = 'animal-tile' + (selectedGroupIds.has(g.groupId) ? ' active' : '');
        const mini = document.createElement('canvas'); mini.width = 48; mini.height = 36;
        const mctx = mini.getContext('2d');
        const firstVariant = g.variants[0];
        const img = IMAGES.get(firstVariant.id);
        if (img) { mctx.drawImage(img, 8, 4, 32, 28); } else { mctx.fillStyle = '#9aa7c7'; mctx.fillRect(8,4,32,28); }
        const name = document.createElement('div'); name.className = 'animal-name'; name.textContent = g.name;
        const nums = document.createElement('div'); nums.className = 'mini-nums';
        const cfg = perGroup.get(g.groupId) || {min:3,max:6};
        const inpMin = document.createElement('input'); inpMin.type = 'number'; inpMin.className = 'num'; inpMin.min = '0'; inpMin.max = '120'; inpMin.value = String(cfg.min);
        const inpMax = document.createElement('input'); inpMax.type = 'number'; inpMax.className = 'num'; inpMax.min = '0'; inpMax.max = '120'; inpMax.value = String(cfg.max);
        inpMin.addEventListener('click', e => e.stopPropagation());
        inpMax.addEventListener('click', e => e.stopPropagation());
        inpMin.addEventListener('input', () => { const v = +inpMin.value|0; const cur = perGroup.get(g.groupId); cur.min = clamp(v, 0, 999); if (cur.max < cur.min) { cur.max = cur.min; inpMax.value = String(cur.max); } });
        inpMax.addEventListener('input', () => { const v = +inpMax.value|0; const cur = perGroup.get(g.groupId); cur.max = clamp(v, 0, 999); if (cur.max < cur.min) { cur.min = cur.max; inpMin.value = String(cur.min); } });
        nums.appendChild(inpMin); nums.appendChild(inpMax);
        tile.appendChild(mini); tile.appendChild(name); tile.appendChild(nums);
        tile.addEventListener('click', () => { if (selectedGroupIds.has(g.groupId)) selectedGroupIds.delete(g.groupId); else selectedGroupIds.add(g.groupId); renderAnimalGrid(); });
        animalGrid.appendChild(tile);
      });
    }

    function computeBounds(itemRadius){
      const w = canvas.clientWidth, h = canvas.clientHeight;
      const left = itemRadius + 10; const right = w - itemRadius - 10;
      const top = itemRadius + 10; const bottom = h - itemRadius - 10;
      return {left,right,top,bottom};
    }

    function generatePositions(total, itemRadius, extraGap){
      const minGap = 2*itemRadius + extraGap;
      const bounds = computeBounds(itemRadius);
      const pts = [];
      let tries = 0, maxTries = total * 400;
      let gap = minGap;
      while (pts.length < total && tries < maxTries){
        const x = randInt(bounds.left, bounds.right);
        const y = randInt(bounds.top, bounds.bottom);
        let ok = true;
        for (let i=0;i<pts.length;i++) { if (distance(pts[i].x, pts[i].y, x, y) < gap) { ok=false; break; } }
        if (ok) pts.push({x,y});
        tries++;
        if (tries % 1000 === 0 && gap > minGap*0.7) gap *= 0.95; // слегка ослабляем зазор если тяжело разместить
      }
      // если всё равно не уместили, обрежем количество
      return pts;
    }

    function buildAndDraw(){
      const cfg = {
        participatingCount: +ui.participatingCount.value|0,
        itemRadius: +ui.itemRadius.value|0,
        scalePercent: +ui.scalePercent.value|0,
        extraGap: +ui.extraGap.value|0,
      };
      const activeGroupIds = pickActiveTypes(selectedGroupIds, cfg.participatingCount);
      const counts = new Map();
      let total = 0;
      activeGroupIds.forEach(gid => {
        const c = perGroup.get(gid) || {min:1,max:1};
        const n = randInt(c.min, Math.max(c.min, c.max));
        counts.set(gid, n); total += n;
      });
      const drawRadius = cfg.itemRadius * 2 * (cfg.scalePercent>0? cfg.scalePercent/100 : 1);
      const pts = generatePositions(total, drawRadius, cfg.extraGap);
      // Для каждой группы выбираем один вариант (модель) и используем его для всех элементов группы
      const chosenVariantByGroup = new Map();
      activeGroupIds.forEach(gid => {
        const group = GROUP_BY_ID[gid];
        const v = group.variants[Math.floor(Math.random() * group.variants.length)];
        chosenVariantByGroup.set(gid, v.id);
      });
      const idsPool = [];
      counts.forEach((n,gid) => {
        const group = GROUP_BY_ID[gid];
        const chosenId = chosenVariantByGroup.get(gid) || group.variants[0].id;
        for (let i=0;i<n;i++) idsPool.push(chosenId);
      });
      shuffle(idsPool);
      const items = [];
      for (let i=0;i<pts.length && i<idsPool.length; i++){
        items.push({ x: pts[i].x, y: pts[i].y, id: idsPool[i] });
      }
      lastState = { cfg: { ...cfg, drawRadius }, items, activeGroupIds };
      drawScene(lastState);
      renderCountingPanel();
    }

    function renderCountingPanel(){
      if (!lastState) return;
      countFields.innerHTML = '';
      let totalLegs = 0;
      
      // Создаём поля для каждого активного типа животных
      for (const gid of lastState.activeGroupIds){
        const group = GROUP_BY_ID[gid];
        const count = lastState.items.filter(item => {
          const itemGroup = ALL_VARIANTS.find(v => v.id === item.id);
          return itemGroup && ANIMAL_GROUPS.find(g => g.variants.some(v => v.id === item.id))?.groupId === gid;
        }).length;
        
        const legs = group.legs;
        const totalLegsForType = count * legs;
        totalLegs += totalLegsForType;
        
        // Находим вариант животного, который используется на поле
        const usedVariant = lastState.items.find(item => {
          const itemGroup = ALL_VARIANTS.find(v => v.id === item.id);
          return itemGroup && ANIMAL_GROUPS.find(g => g.variants.some(v => v.id === item.id))?.groupId === gid;
        });
        
        const field = document.createElement('div');
        field.className = 'count-field';
        field.dataset.groupId = gid;
        
        const icon = document.createElement('canvas');
        icon.className = 'animal-icon';
        icon.width = 32; icon.height = 32;
        const ictx = icon.getContext('2d');
        
        if (usedVariant) {
          const img = IMAGES.get(usedVariant.id);
          if (img) { ictx.drawImage(img, 0, 0, 32, 32); } else { ictx.fillStyle = '#9aa7c7'; ictx.fillRect(0,0,32,32); }
        } else {
          // Fallback на первый вариант группы
          const firstVariant = group.variants[0];
          const img = IMAGES.get(firstVariant.id);
          if (img) { ictx.drawImage(img, 0, 0, 32, 32); } else { ictx.fillStyle = '#9aa7c7'; ictx.fillRect(0,0,32,32); }
        }
        
        const label = document.createElement('div');
        label.textContent = `Всего ног у ${group.name}`;
        label.style.fontSize = '12px';
        label.style.minWidth = '80px';
        
        const input = document.createElement('input');
        input.type = 'number';
        input.min = '0';
        input.max = '999';
        input.placeholder = '?';
        input.dataset.correctValue = totalLegsForType;
        
        field.appendChild(icon);
        field.appendChild(label);
        field.appendChild(input);
        countFields.appendChild(field);
      }
      
      totalInput.value = '';
      totalField.dataset.correctValue = totalLegs;
      
      // Очищаем предыдущие результаты проверки
      document.querySelectorAll('.count-field, .total-field').forEach(el => {
        el.classList.remove('correct', 'incorrect');
      });
    }

    function checkAnswers(){
      if (!lastState) return;
      
      let allCorrect = true;
      
      // Проверяем поля с типами животных
      document.querySelectorAll('.count-field').forEach(field => {
        const input = field.querySelector('input');
        const userValue = +input.value || 0;
        const correctValue = +input.dataset.correctValue || 0;
        
        if (userValue === correctValue) {
          field.classList.remove('incorrect');
          field.classList.add('correct');
        } else {
          field.classList.remove('correct');
          field.classList.add('incorrect');
          allCorrect = false;
        }
      });
      
      // Проверяем общее количество ног
      const totalUserValue = +totalInput.value || 0;
      const totalCorrectValue = +totalField.dataset.correctValue || 0;
      
      if (totalUserValue === totalCorrectValue) {
        totalField.classList.remove('incorrect');
        totalField.classList.add('correct');
      } else {
        totalField.classList.remove('correct');
        totalField.classList.add('incorrect');
        allCorrect = false;
      }
      
      if (allCorrect) {
        // Все ответы верные - поля уже подсвечены зелёным
      }
    }

    function drawScene(state){
      const w = canvas.clientWidth, h = canvas.clientHeight;
      ctx.clearRect(0,0,w,h);
      if (!state) return;
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      const r = state.cfg.drawRadius || state.cfg.itemRadius;
      for (const it of state.items){
        const img = IMAGES.get(it.id);
        if (!img) continue;
        const iw = r*2, ih = r*2;
        ctx.drawImage(img, it.x - iw/2, it.y - ih/2, iw, ih);
      }
    }

    function openSettings(){ overlay.style.display = 'flex'; }
    function closeSettings(){ overlay.style.display = 'none'; }

    document.addEventListener('keydown', (e) => { if (e.key === 'Escape') closeSettings(); });
    btnNew.addEventListener('click', () => { closeSettings(); buildAndDraw(); });
    btnSettings.addEventListener('click', () => { openSettings(); });
    btnCancel.addEventListener('click', () => { closeSettings(); });
    btnApply.addEventListener('click', () => { closeSettings(); buildAndDraw(); });
    checkBtn.addEventListener('click', checkAnswers);
    btnRandomize.addEventListener('click', () => {
      ui.participatingCount.value = String(randInt(1, ANIMAL_GROUPS.length));
      ui.itemRadius.value = String(randInt(18, 28));
      ui.extraGap.value = String(randInt(2, 10));
      ANIMAL_GROUPS.forEach(g => {
        const mn = randInt(2, 6);
        const mx = randInt(mn, mn + 6);
        const cur = perGroup.get(g.groupId) || {min:mn,max:mx};
        cur.min = mn; cur.max = mx; perGroup.set(g.groupId, cur);
      });
      renderAnimalGrid();
    });

    let lastState = null;
    preloadImages(ALL_VARIANTS).then(() => { renderAnimalGrid(); resizeCanvas(); renderCountingPanel(); openSettings(); });
  </script>
</body>
</html>


