<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CutFigure — разрезай фигуру</title>
    <link rel="icon" href="favicon.ico" type="image/x-icon">
    <style>
        body {
            font-family: 'Arial', sans-serif;
            margin: 0;
            padding: 0;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            color: #fff;
            position: relative;
        }
        body::before {
            content: '';
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: linear-gradient(rgba(0,0,0,0.6), rgba(0,0,0,0.1)), url('img/f1.jpg') center/cover no-repeat;
            z-index: -2;
        }
        body::after {
            content: '';
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: linear-gradient(135deg, rgba(110,142,251,0.8), rgba(167,119,227,0.3));
            z-index: -1;
        }
        .container {
            margin-top: 40px;
            background: rgba(255,255,255,0.15);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            box-shadow: 0 8px 32px 0 rgba(31,38,135,0.2);
            border: 1px solid rgba(255,255,255,0.18);
            padding: 30px 40px 40px 40px;
            width: min(1100px, 96vw);
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .title {
            font-size: 2em;
            font-weight: bold;
            margin-bottom: 10px;
            color: #fff;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.5);
        }
        .settings {
            display: flex;
            gap: 24px;
            margin-bottom: 24px;
            flex-wrap: wrap;
            justify-content: center;
        }
        .settings label { margin-right: 8px; }
        .board-wrap {
            position: relative;
            background: rgba(255,255,255,0.18);
            border-radius: 12px;
            box-shadow: 0 4px 16px 0 rgba(31,38,135,0.15);
            border: 1px solid rgba(255,255,255,0.15);
            padding: 10px;
        }
        .grid {
            display: grid;
            gap: 0;
            background: #fff;
            border: 2px solid #222;
        }
        .cell {
            width: 40px;
            height: 40px;
            box-sizing: border-box;
            background: #ff6666;
            border: 1px solid #222;
        }
        .cell.empty { background: #f2f2f2; }
        svg.edges {
            position: absolute;
            left: 10px; top: 10px;
            pointer-events: none;
        }
        .hint { margin-top: 10px; font-size: 0.95em; opacity: 0.9; }
        .back-button {
            display: inline-flex;
            justify-content: center;
            align-items: center;
            width: 50px;
            height: 50px;
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            font-size: 24px;
            border-radius: 50%;
            text-decoration: none;
            margin-left: 12px;
            transition: all 0.3s;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            border: none;
        }
        .back-button:hover { transform: scale(1.1); }
        .mode-buttons {
            display: flex;
            gap: 12px;
            margin-bottom: 20px;
            justify-content: center;
            flex-wrap: wrap;
        }
        .mode-btn {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 25px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        .mode-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
        }
        .mode-btn.active {
            background: linear-gradient(135deg, #ff6b6b, #ee5a24);
            box-shadow: 0 6px 12px rgba(255, 107, 107, 0.4);
        }
        @media (max-width: 700px) {
            .cell { width: 34px; height: 34px; }
        }
    </style>
 </head>
 <body>
    <div class="container">
        <div class="title">CutFigure — разрезай фигуру <a href="index.html" class="back-button">←</a></div>
        <div class="mode-buttons">
            <button class="mode-btn active" onclick="location.href='CutFigure.html'">Квадраты</button>
            <button class="mode-btn" onclick="location.href='CutFigureTriangle.html'">Треугольники</button>
            <button class="mode-btn" onclick="location.href='CutFigureHex.html'">Шестиугольники</button>
        </div>
        <div class="settings">
            <label>Клеток в части:
                <input type="number" id="cellsCount" min="2" max="30" value="4" style="width:70px;">
            </label>
            <label>Делить на части:
                <select id="partsCount">
                    <option value="2">2</option>
                    <option value="3">3</option>
                    <option value="4">4</option>
                </select>
            </label>
            <label>Цвет:
                <input type="color" id="figColor" value="#ff6666">
            </label>
            <button id="regenBtn" style="background:linear-gradient(to right,#00c6ff,#0072ff);color:#fff;border:none;padding:8px 18px;border-radius:8px;font-weight:bold;cursor:pointer;box-shadow:0 2px 8px #00c6ff44;">Сгенерировать</button>
        </div>
        <div class="board-wrap">
            <div id="grid" class="grid"></div>
            <svg id="edges" class="edges"></svg>
        </div>
        <div class="hint">Клик по границе между клетками — поставить/убрать утолщённую линию.</div>
    </div>
    <script>
    // Параметры
    const gridEl = document.getElementById('grid');
    const edgesSvg = document.getElementById('edges');
    const cellsCountInput = document.getElementById('cellsCount');
    const partsCountSelect = document.getElementById('partsCount');
    const colorInput = document.getElementById('figColor');
    const regenBtn = document.getElementById('regenBtn');

    let shapeCells = []; // массив координат {r,c}
    let cellPartLabels = new Map(); // ключ "r,c" -> id части
    let rows = 8, cols = 8; // размеры холста
    let figureColor = colorInput.value;
    let cellSize = 40; // px, синхронизирован со стилем .cell

    // Вспомогательные для полимино
    const keyRC = (r,c)=>`${r},${c}`;
    function rotate90(coords){
        // поворот вокруг (0,0): (r,c) -> (c, -r)
        return coords.map(({r,c})=>({r:c,c:-r}));
    }
    function normalizeCoords(coords){
        const minR = Math.min(...coords.map(p=>p.r));
        const minC = Math.min(...coords.map(p=>p.c));
        return coords.map(p=>({r:p.r-minR,c:p.c-minC}));
    }
    function rotateNTimes(coords, times){
        let cur = coords;
        for(let i=0;i<times;i++) cur = rotate90(cur);
        return normalizeCoords(cur);
    }
    function bbox(coords){
        const maxR = Math.max(...coords.map(p=>p.r));
        const maxC = Math.max(...coords.map(p=>p.c));
        return {h:maxR+1,w:maxC+1};
    }
    // Генерация одной части (связное полимино) из n клеток
    function generateBasePart(n){
        const set = new Set();
        set.add(keyRC(0,0));
        let frontier = [{r:0,c:0}];
        while(set.size < n){
            const {r,c} = frontier[Math.floor(Math.random()*frontier.length)];
            const neigh = [{r:r+1,c},{r:r-1,c},{r,c:c+1},{r,c:c-1}];
            const candidates = neigh.filter(p=>!set.has(keyRC(p.r,p.c)));
            if(candidates.length===0){ frontier = Array.from(set).map(s=>{const [rr,cc]=s.split(','); return {r:+rr,c:+cc};}); continue; }
            const np = candidates[Math.floor(Math.random()*candidates.length)];
            set.add(keyRC(np.r,np.c));
            frontier.push(np);
        }
        let coords = Array.from(set).map(s=>{const [r,c]=s.split(',').map(Number); return {r,c};});
        coords = normalizeCoords(coords);
        return coords;
    }
    // Пытаемся разместить часть без перекрытий и с касанием к уже размещённым клеткам
    function tryPlacePart(partCoords, occupied){
        const {h,w} = bbox(partCoords);
        const maxRange = Math.max(8, h+w+6);
        // рассмотрим смещения в окрестности, чтобы найти касание
        const offsets = [];
        for(let dr=-maxRange; dr<=maxRange; dr++){
            for(let dc=-maxRange; dc<=maxRange; dc++){
                offsets.push([dr,dc]);
            }
        }
        // случайный порядок перебора
        for(let i=offsets.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [offsets[i],offsets[j]]=[offsets[j],offsets[i]]; }
        for(const [dr,dc] of offsets){
            let overlap = false; let touch = false;
            for(const p of partCoords){
                const r = p.r+dr, c = p.c+dc;
                const k = keyRC(r,c);
                if(occupied.has(k)){ overlap = true; break; }
                // проверка касания по стороне
                if(!touch){
                    const neigh = [keyRC(r+1,c),keyRC(r-1,c),keyRC(r,c+1),keyRC(r,c-1)];
                    for(const nk of neigh){ if(occupied.has(nk)){ touch = true; break; } }
                }
            }
            if(!overlap && (occupied.size===0 || touch)){
                return {ok:true, dr, dc};
            }
        }
        return {ok:false};
    }
    // Сборка фигуры из k одинаковых частей (с разрешёнными поворотами)
    function assembleFigure(partSize, parts){
        const base = generateBasePart(partSize);
        const occupied = new Set();
        cellPartLabels = new Map();
        shapeCells = [];
        for(let pid=0; pid<parts; pid++){
            const rot = Math.floor(Math.random()*4);
            const rotated = rotateNTimes(base, rot);
            const placement = tryPlacePart(rotated, occupied);
            if(!placement.ok){
                // если не получилось, попробуем заново всю сборку
                return assembleFigure(partSize, parts);
            }
            for(const p of rotated){
                const r = p.r + placement.dr;
                const c = p.c + placement.dc;
                const k = keyRC(r,c);
                occupied.add(k);
                cellPartLabels.set(k, pid);
                shapeCells.push({r,c});
            }
        }
        normalizeShape();
    }

    // Сдвигаем фигуру в левый верхний угол (минимальные r,c = 0)
    function normalizeShape() {
        if (shapeCells.length===0) return;
        const minR = Math.min(...shapeCells.map(p=>p.r));
        const minC = Math.min(...shapeCells.map(p=>p.c));
        const relabeled = new Map();
        shapeCells = shapeCells.map(p=>({r:p.r-minR,c:p.c-minC}));
        // сдвигаем и метки частей
        cellPartLabels.forEach((val,key)=>{
            const [r,c] = key.split(',').map(Number);
            const nk = keyRC(r-minR, c-minC);
            relabeled.set(nk, val);
        });
        cellPartLabels = relabeled;
        rows = Math.max(...shapeCells.map(p=>p.r))+3;
        cols = Math.max(...shapeCells.map(p=>p.c))+3;
    }

    // Отрисовка сетки и фигуры
    function renderBoard() {
        const maxR = Math.max(...shapeCells.map(p=>p.r));
        const maxC = Math.max(...shapeCells.map(p=>p.c));
        const pad = 2;
        const R = Math.max(maxR+pad+1, 6);
        const C = Math.max(maxC+pad+1, 6);
        gridEl.style.gridTemplateRows = `repeat(${R}, ${cellSize}px)`;
        gridEl.style.gridTemplateColumns = `repeat(${C}, ${cellSize}px)`;
        gridEl.innerHTML = '';
        const set = new Set(shapeCells.map(p=>p.r+','+p.c));
        for (let r=0;r<R;r++){
            for (let c=0;c<C;c++){
                const cell = document.createElement('div');
                cell.className = 'cell' + (set.has(r+','+c)?'':' empty');
                cell.dataset.r = r;
                cell.dataset.c = c;
                cell.style.background = set.has(r+','+c) ? figureColor : '#f2f2f2';
                gridEl.appendChild(cell);
            }
        }
        // настроим SVG поверх
        const w = C*cellSize + 0;
        const h = R*cellSize + 0;
        edgesSvg.setAttribute('width', w);
        edgesSvg.setAttribute('height', h);
        edgesSvg.innerHTML = '';
        // создадим невидимые кликабельные сегменты-границы между клетками
        addEdgeHotspots(R,C);
    }

    // Множество активных утолщённых линий по ключу "r,c,dir" dir in {H,V}
    const thickEdges = new Set();

    function addEdgeHotspots(R,C){
        const strokeThin = 1;
        const strokeThick = 5;
        // горизонтальные границы
        for(let r=0;r<=R;r++){
            for(let c=0;c<C;c++){
                const x1=c*cellSize, y=r*cellSize, x2=(c+1)*cellSize, y2=y;
                const key = `${r},${c},H`;
                const g = document.createElementNS('http://www.w3.org/2000/svg','g');
                // тонкая сетка
                const base = document.createElementNS('http://www.w3.org/2000/svg','line');
                base.setAttribute('x1',x1); base.setAttribute('y1',y);
                base.setAttribute('x2',x2); base.setAttribute('y2',y2);
                base.setAttribute('stroke','#222'); base.setAttribute('stroke-width', strokeThin);
                edgesSvg.appendChild(base);
                // толстая линия (переключаемая)
                const thick = document.createElementNS('http://www.w3.org/2000/svg','line');
                thick.setAttribute('x1',x1); thick.setAttribute('y1',y);
                thick.setAttribute('x2',x2); thick.setAttribute('y2',y2);
                thick.setAttribute('stroke','#111'); thick.setAttribute('stroke-width', strokeThick);
                thick.setAttribute('stroke-linecap','round');
                thick.setAttribute('opacity', '0');
                thick.style.pointerEvents = 'auto';
                thick.addEventListener('click', ()=>{
                    if(thickEdges.has(key)){ thickEdges.delete(key); thick.setAttribute('opacity','0'); }
                    else { thickEdges.add(key); thick.setAttribute('opacity','1'); }
                });
                edgesSvg.appendChild(thick);
            }
        }
        // вертикальные границы
        for(let c=0;c<=C;c++){
            for(let r=0;r<C?R:0;r++){}
        }
        for(let c=0;c<=C;c++){
            for(let r=0;r<R;r++){
                const x=c*cellSize, y1=r*cellSize, x2=x, y2=(r+1)*cellSize;
                const key = `${r},${c},V`;
                const base = document.createElementNS('http://www.w3.org/2000/svg','line');
                base.setAttribute('x1',x); base.setAttribute('y1',y1);
                base.setAttribute('x2',x2); base.setAttribute('y2',y2);
                base.setAttribute('stroke','#222'); base.setAttribute('stroke-width', 1);
                edgesSvg.appendChild(base);
                const thick = document.createElementNS('http://www.w3.org/2000/svg','line');
                thick.setAttribute('x1',x); thick.setAttribute('y1',y1);
                thick.setAttribute('x2',x2); thick.setAttribute('y2',y2);
                thick.setAttribute('stroke','#111'); thick.setAttribute('stroke-width', 5);
                thick.setAttribute('stroke-linecap','round');
                thick.setAttribute('opacity','0');
                thick.style.pointerEvents = 'auto';
                thick.addEventListener('click', ()=>{
                    if(thickEdges.has(key)){ thickEdges.delete(key); thick.setAttribute('opacity','0'); }
                    else { thickEdges.add(key); thick.setAttribute('opacity','1'); }
                });
                edgesSvg.appendChild(thick);
            }
        }
    }

    function regenerate(){
        figureColor = colorInput.value;
        const part = Math.max(2, Math.min(60, +cellsCountInput.value||4));
        const parts = +partsCountSelect.value;
        assembleFigure(part, parts);
        renderBoard();
    }

    colorInput.addEventListener('input', ()=>{
        figureColor = colorInput.value;
        document.querySelectorAll('.cell').forEach(el=>{
            if(!el.classList.contains('empty')) el.style.background = figureColor;
        });
    });
    regenBtn.addEventListener('click', regenerate);
    partsCountSelect.addEventListener('change', regenerate);
    window.addEventListener('resize', ()=>{
        // пересчитать размеры SVG
        const style = getComputedStyle(document.querySelector('.cell'));
        const w = parseFloat(style.width);
        if(!isNaN(w) && Math.abs(w - cellSize) > 0.1){ cellSize = w; renderBoard(); }
    });

    // первая генерация
    regenerate();
    </script>
 </body>
 </html>


